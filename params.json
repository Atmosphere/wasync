{"name":"Wasync","tagline":"WebSockets with fallback transports client library for Node.js, Android and Java","body":"## wAsync: A WebSockets/HTTP Client Library for Asynchronous Communication\r\n\r\nwAsync is a Java based library allowing asynchronous communication with any WebServer supporting the WebSocket or Http Protocol.\r\nwAsync can be used with Node.js, Android, Atmosphere or any WebSocket Framework. To get started, read this super simple [Tutorial](https://github.com/Atmosphere/wasync/wiki/Getting-Started-with-wAsync)\r\n\r\nYou can browse the [javadoc](http://atmosphere.github.com/wasync/apidocs/) or browse our [samples](https://github.com/Atmosphere/wasync/tree/master/samples).\r\n\r\nYou can [download the jar](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22wasync%22) or use Maven\r\n```xml\r\n          <dependency>\r\n              <groupId>org.atmosphere</groupId>\r\n              <artifactId>wasync</artifactId>\r\n              <version>1.0.0.RC5</version>\r\n          </dependency>\r\n\r\n```\r\nAs simple as\r\n\r\n```java\r\n        Client client = ClientFactory.getDefault().newClient();\r\n\r\n        RequestBuilder request = client.newRequestBuilder()\r\n                .method(Request.METHOD.GET)\r\n                .uri(\"http://async-io.org\")\r\n                .encoder(new Encoder<String, Reader>() {        // Stream the request body\r\n                    @Override\r\n                    public Reader encode(String s) {\r\n                        return new StringReader(s);\r\n                    }\r\n                })\r\n                .decoder(new Decoder<String, Reader>() {\r\n                    @Override\r\n                    public Reader decode(Event type, String s) {\r\n                        return new StringReader(s);\r\n                    }\r\n                })\r\n                .transport(Request.TRANSPORT.WEBSOCKET)                        // Try WebSocket\r\n                .transport(Request.TRANSPORT.LONG_POLLING);                    // Fallback to Long-Polling\r\n\r\n        Socket socket = client.create();\r\n        socket.on(new Function<Reader>() {\r\n            @Override\r\n            public void on(Reader r) {\r\n                // Read the response\r\n            }\r\n        }).on(new Function<IOException>() {\r\n\r\n            @Override\r\n            public void on(Throwable t) {\r\n                // Some IOException occurred\r\n            }\r\n\r\n        }).open(request.build())\r\n            .fire(\"echo\")\r\n            .fire(\"bong\");\r\n```\r\nLife cycle of the underlying Socket can easily be implemented as well\r\n```java\r\n\r\n           Socket socket = client.create();\r\n           socket.on(Event.CLOSE.name(), new Function<String>() {\r\n               @Override\r\n               public void on(String t) {\r\n               }\r\n           }).on(Event.REOPENED.name(), new Function<String>() {\r\n               @Override\r\n               public void on(String t) {\r\n               }\r\n           }).on(new Function<IOException>() {\r\n               @Override\r\n               public void on(IOException ioe) {\r\n                   ioe.printStackTrace();\r\n               }\r\n           }).on(Event.OPEN.name(), new Function<String>() {\r\n               @Override\r\n               public void on(String t) {\r\n               }\r\n           }).open(request.build());\r\n```\r\n\r\nYou can also use the specialized clients. For example, to transparently enable Atmosphere's Protocol\r\n\r\n```java\r\n       AtmosphereClient client = ClientFactory.getDefault().newClient(AtmosphereClient.class);\r\n\r\n       RequestBuilder request = client.newRequestBuilder()\r\n    \t\t   .method(Request.METHOD.GET)\r\n    \t\t   .uri(targetUrl + \"/suspend\")\r\n               .trackMessageLength(true)\r\n    \t\t   .transport(Request.TRANSPORT.LONG_POLLING);\r\n```\r\n\r\nor if you want to serialize the fire() method call so events are asynchronously sent in the order the fire method is called\r\n\r\n```java\r\n        SerializedClient client = ClientFactory.getDefault().newClient(SerializedClient.class);\r\n\r\n        SerializedOptionsBuilder b = client.newOptionsBuilder();\r\n        b.serializedFireStage(new DefaultSerializedFireStage());\r\n\r\n        RequestBuilder request = client.newRequestBuilder()\r\n                .method(Request.METHOD.GET)\r\n                .uri(targetUrl + \"/suspend\")\r\n                .transport(Request.TRANSPORT.WEBSOCKET);\r\n\r\n        Socket socket = client.create(b.build());\r\n```\r\n\r\nBy default, the [FunctionResolver](http://atmosphere.github.com/wasync/apidocs/org/atmosphere/wasync/FunctionResolver.html) will associate the Decoder's type will be used to invoke the appropriate Function, if defined. For\r\nexample,\r\n\r\n```java\r\n   Decoder<String, POJO> d = new Decoder<String, POJO>() {\r\n             @Override\r\n             public POJO decode(Event type, String s) {\r\n                 if (type.equals(Event.MESSAGE)) {\r\n                    return new POJO(s);\r\n                 } else {\r\n                    return s;\r\n                 }\r\n             }\r\n         }\r\n```\r\nwill be associated to\r\n```java\r\n   Function<String> f = new Function<POJO>() {\r\n             @Override\r\n             public void on(POJO t) {\r\n\r\n             }\r\n        }\r\n```\r\nYou can also implement your own FunctionResolver to associate the Function with Decoder\r\n```java\r\n         Socket socket = client.create();\r\n         socket.on(\"myEvent\", new Function<Reader>() { ...}\r\n```\r\nwhere myEvent could be read from the response's body.\r\n\r\nWant to write an Android Client? [See](http://jfarcand.wordpress.com/2013/04/04/wasync-websockets-with-fallbacks-transports-for-android-node-js-and-atmosphere/)\r\n\r\n\r\n[![githalytics.com alpha](https://cruel-carlota.pagodabox.com/6565d992c41200f6a5617e646f291569 \"githalytics.com\")](http://githalytics.com/Atmosphere/wasync)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}